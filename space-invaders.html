<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Space Invaders – Autostart (Level 3 Boss)</title>
<style>
  html,body{margin:0;height:100%;background:#05060d;color:#e9f2ff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{display:grid;place-items:center;height:100%}
  canvas{width:min(96vw,900px);aspect-ratio:4/3;background:#0b1022;border:1px solid #1d2a5a;border-radius:10px;box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .hint{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(15,20,40,.65);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px;font-weight:600}
  .kbd{display:inline-block;padding:2px 6px;border-radius:6px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);font-family:ui-monospace,monospace}
</style>
</head>
<body><button onclick="window.location.href='index.html'">Back to Home</button>
<div id="wrap">
  <canvas id="game" width="800" height="600" aria-label="Space Invaders Canvas"></canvas>
</div>
<div class="hint">Move <span class="kbd">←</span>/<span class="kbd">→</span>, Fire <span class="kbd">Space</span>, Pause <span class="kbd">P</span>, Restart <span class="kbd">R</span></div>
<script>
(()=>{
  const c = document.getElementById('game');
  const g = c.getContext('2d');
  const W=c.width,H=c.height, PAD=20;
  const PLAYER={w:48,h:18,speed:320,reload:250};
  const BULLET={w:4,h:10,vy:-520};
  const E_BULLET={w:4,h:10,vy:240}; // enemy bullets can also have vx
  const INV={w:28,h:18,gx:16,gy:16,rows:5,cols:11,step:16};

  let state='running';
  let score=0,lives=3,level=1;
  let player,bullets,ebullets,enemies,invDir,invSpeed,lastEnemyShotAt=0;
  let lastBossBurstAt=0;
  let keys={left:false,right:false,fire:false};
  let time=0; // seconds

  function resetPlayer(){player={x:W/2-PLAYER.w/2,y:H-60,w:PLAYER.w,h:PLAYER.h,canShootAt:0};}

  function buildEnemies(){
    enemies=[];
    const isBossLevel = (level%3===0); // boss on level 3,6,9,...
    if(isBossLevel){
      const bossW=140, bossH=70;
      const boss = {type:'BOSS', x:W/2-bossW/2, y:110, baseY:110, w:bossW, h:bossH, alive:true, hp:80+Math.max(0,(level-3))*25, val: 300+level*50, dir:1};
      enemies.push(boss);
      // Add 6 orbiting guards with 2 HP each
      const guards = 6; const radius = 70; 
      for(let i=0;i<guards;i++){
        enemies.push({type:'GUARD', x:0, y:0, w:20, h:20, alive:true, hp:2, val:20, angle:(i/guards)*Math.PI*2, speed: (0.8 + i*0.05)});
      }
      invDir=1; invSpeed=80 + (level-3)*10; // boss horizontal speed
      return;
    }

    // Regular wave
    const totalW=INV.cols*INV.w+(INV.cols-1)*INV.gx;
    const sx=(W-totalW)/2, sy=80;
    for(let r=0;r<INV.rows;r++){
      for(let cI=0;cI<INV.cols;cI++){
        const baseX = sx+cI*(INV.w+INV.gx);
        const baseY = sy+r*(INV.h+INV.gy);
        // Level 1: type A only. Level >=2: mix in type B on the top 2 rows and some random others.
        const typeB = (level>=2) && (r<=1 || Math.random()<0.18);
        enemies.push({
          type: typeB? 'B':'A',
          x: baseX,
          baseY: baseY,
          y: baseY,
          rowDrop: 0,
          w: INV.w, h: INV.h,
          alive: true,
          val: (typeB? 30:10) + (INV.rows - r)*5,
          phase: Math.random()*Math.PI*2,
          freq: 3 + Math.random()*1.5,
          amp: 6 + Math.random()*6
        });
      }
    }
    invDir=1; invSpeed=26+(level-1)*8; // base speed
  }

  function resetLevel(){bullets=[]; ebullets=[]; lastEnemyShotAt=0; lastBossBurstAt=0; resetPlayer(); buildEnemies();}
  resetLevel();

  function aabb(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y}

  function input(dt){
    let vx=0; if(keys.left)vx-=1; if(keys.right)vx+=1;
    player.x+=vx*PLAYER.speed*dt; player.x=Math.max(PAD,Math.min(W-PAD-player.w,player.x));
    const now=performance.now();
    if(keys.fire && now>player.canShootAt){
      bullets.push({x:player.x+player.w/2-BULLET.w/2,y:player.y-BULLET.h,w:BULLET.w,h:BULLET.h,vy:BULLET.vy});
      player.canShootAt=now+PLAYER.reload*Math.max(.55,1-(level-1)*.06);
    }
  }

  function updateBullets(dt){
    for(const b of bullets){ b.y+=b.vy*dt; }
    bullets=bullets.filter(b=>b.y+b.h>0);
    for(const b of ebullets){ b.y+=b.vy*dt; if(b.vx) b.x+=b.vx*dt; }
    ebullets=ebullets.filter(b=>b.y<H+60 && b.x>-60 && b.x<W+60);
  }

  function enemiesAlive(){return enemies.filter(e=>e.alive)}

  function updateEnemies(dt){
    const alive=enemiesAlive(); if(!alive.length){ level++; resetLevel(); return; }

    const isBossLevel=(level%3===0);
    if(isBossLevel){
      const boss = enemies.find(e=>e.type==='BOSS' && e.alive);
      if(!boss){ // all guards cleared earlier somehow, proceed
        level++; resetLevel(); return;
      }
      // Boss movement: horizontal sweep + bobbing
      boss.x += invDir * invSpeed * dt;
      if(boss.x < PAD){ boss.x = PAD; invDir = 1; }
      if(boss.x + boss.w > W-PAD){ boss.x = W-PAD-boss.w; invDir = -1; }
      boss.y = boss.baseY + Math.sin(time*2)*8;

      // Update guard orbits around the boss center
      const cx = boss.x + boss.w/2, cy = boss.y + boss.h/2;
      const radius = 75;
      for(const gobj of enemies){
        if(gobj.type!=='GUARD' || !gobj.alive) continue;
        gobj.angle += dt * (0.9 + gobj.speed*0.15);
        gobj.x = cx + radius*Math.cos(gobj.angle) - gobj.w/2;
        gobj.y = cy + radius*Math.sin(gobj.angle) - gobj.h/2;
      }

      // Boss shooting patterns
      const now=performance.now();
      // Aimed shot every ~700ms
      if(now-lastEnemyShotAt>700){
        lastEnemyShotAt=now;
        const bx = boss.x + boss.w/2, by = boss.y + boss.h;
        const dx = (player.x+player.w/2) - bx; const dy = (player.y) - by;
        const len = Math.hypot(dx,dy)||1; const spd=270;
        ebullets.push({x:bx-2,y:by,w:4,h:10,vy: spd*(dy/len), vx: spd*(dx/len)});
      }
      // Radial burst every ~3.2s
      if(now-lastBossBurstAt>3200){
        lastBossBurstAt=now;
        const bx = boss.x + boss.w/2, by = boss.y + boss.h/2;
        const n=10, spd=220;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2;
          ebullets.push({x:bx-2,y:by-2,w:4,h:10,vy: spd*Math.sin(a), vx: spd*Math.cos(a)});
        }
      }
      return; // skip normal invader logic
    }

    // === Normal waves (with Type A/B) ===
    const speedScale=1+(1-alive.length/(INV.rows*INV.cols))*1.6 + (level-1)*.1;
    const v=invSpeed*speedScale*invDir;

    let minX=1e9,maxX=-1e9,maxY=-1e9;
    for(const e of alive){ e.x+=v*dt; }
    for(const e of alive){
      const bob = (e.type==='B'? Math.sin((time*e.freq)+e.phase)*e.amp : 0);
      e.y = e.baseY + e.rowDrop + bob;
      minX=Math.min(minX,e.x); maxX=Math.max(maxX,e.x+e.w); maxY=Math.max(maxY,e.y+e.h);
    }
    if(minX<PAD || maxX>W-PAD){ invDir*=-1; for(const e of alive) e.rowDrop += INV.step; }
    if(maxY>=player.y-8) loseLife();

    // Enemy shooting (bottom-most columns only)
    const now=performance.now();
    const bCount = alive.reduce((n,e)=>n+(e.type==='B'),0);
    const baseRate = 1.1 + (level-1)*0.25;
    const rate = baseRate * (1 + 0.25*(bCount/alive.length));
    const interval=1000/rate;
    if(now-lastEnemyShotAt>interval && alive.length){
      lastEnemyShotAt=now;
      const cols={};
      for(const e of alive){ const col=Math.round((e.x-alive[0].x)/(INV.w+INV.gx)); if(!cols[col]||cols[col].y<e.y) cols[col]=e; }
      const arr=Object.values(cols); const shooter=arr[Math.floor(Math.random()*arr.length)];
      if(shooter){
        if(shooter.type==='B'){
          ebullets.push({x:shooter.x+shooter.w/2-2-6,y:shooter.y+shooter.h,w:E_BULLET.w,h:E_BULLET.h,vy:E_BULLET.vy*1.05,vx:-70});
          ebullets.push({x:shooter.x+shooter.w/2-2+6,y:shooter.y+shooter.h,w:E_BULLET.w,h:E_BULLET.h,vy:E_BULLET.vy*1.05,vx:+70});
        } else {
          ebullets.push({x:shooter.x+shooter.w/2-E_BULLET.w/2,y:shooter.y+shooter.h,w:E_BULLET.w,h:E_BULLET.h,vy:E_BULLET.vy});
        }
      }
    }
  }

  function handleCollisions(){
    // Player bullets vs guards first (blockers), then boss/others
    for(const b of bullets){
      // Check guards
      let blocked=false;
      for(const e of enemies){
        if(!e.alive) continue;
        if(e.type==='GUARD' && aabb(b,e)){
          e.hp--; if(e.hp<=0){ e.alive=false; score+=e.val; }
          b.y=-9999; blocked=true; break;
        }
      }
      if(blocked) continue;
      // Boss/regular enemies
      for(const e of enemies){
        if(!e.alive) continue; if(e.type==='GUARD') continue;
        if(aabb(b,e)){
          if(e.type==='BOSS'){
            e.hp--; if(e.hp<=0){ e.alive=false; score+=e.val; }
          } else {
            e.alive=false; score+=e.val;
          }
          b.y=-9999; break;
        }
      }
    }
    bullets=bullets.filter(b=>b.y>-50);

    // Enemy bullets vs player
    for(const b of ebullets){ if(aabb(b,player)){ b.y=H+9999; loseLife(); break; } }
  }

  function loseLife(){
    lives--; if(lives<=0){ state='gameover'; } else { resetPlayer(); ebullets=[]; bullets=[]; }
  }

  function stars(){
    g.save(); g.globalAlpha=.7; for(let i=0;i<90;i++){ const x=(i*97)%W; const y=((i*i*29+i*7)%H); g.fillStyle=i%9? 'rgba(255,255,255,.10)': 'rgba(106,227,255,.25)'; g.fillRect(x,y,2,2);} g.restore();
  }

  function draw(){
    g.clearRect(0,0,W,H); stars();
    // HUD
    g.fillStyle='rgba(255,255,255,.85)'; g.font='16px system-ui,Segoe UI,Arial'; g.fillText('Score: '+score, 16, 24); g.fillText('Lives: '+lives, 120, 24); g.fillText('Level: '+level, 210, 24);
    // player
    g.fillStyle='#7dfaa3'; g.fillRect(player.x,player.y,player.w,player.h); g.fillRect(player.x+player.w/2-6,player.y-10,12,10);

    // enemies & boss
    for(const e of enemies){ if(!e.alive) continue; 
      if(e.type==='A'){ g.fillStyle='#6ae3ff'; }
      else if(e.type==='B'){ g.fillStyle='#b07bff'; }
      else if(e.type==='GUARD'){ g.fillStyle='#ffd166'; }
      else if(e.type==='BOSS'){ g.fillStyle='#ff6b6b'; }

      if(e.type==='BOSS'){
        // Boss body
        g.fillRect(e.x, e.y+10, e.w, e.h-20);
        g.fillRect(e.x+10, e.y, e.w-20, 14);
        // eyes
        g.fillStyle='#0b1022'; g.fillRect(e.x+25,e.y+8,10,10); g.fillRect(e.x+e.w-35,e.y+8,10,10);
        // health bar
        const hpw = Math.max(0, (e.hp/ (80+Math.max(0,(level-3))*25)) ) * (e.w);
        g.fillStyle='#7dfaa3'; g.fillRect(e.x, e.y-8, hpw, 4);
      } else if(e.type==='GUARD'){
        // Guards as small squares
        g.fillRect(e.x, e.y, e.w, e.h);
      } else {
        // Regular invaders
        g.fillRect(e.x+0,e.y+6,e.w,10); g.fillRect(e.x+5,e.y+0,e.w-10,6); g.fillRect(e.x+4,e.y+16,e.w-8,4);
      }
    }

    // bullets
    g.fillStyle='#ffd166'; for(const b of bullets) g.fillRect(b.x,b.y,b.w,b.h);
    g.fillStyle='#ff6b6b'; for(const b of ebullets) g.fillRect(b.x,b.y,b.w,b.h);

    if(state==='gameover'){
      g.fillStyle='rgba(0,0,0,.5)'; g.fillRect(0,0,W,H);
      g.fillStyle='#ff6b6b'; g.font='bold 40px system-ui,Segoe UI,Arial'; g.fillText('GAME OVER', W/2-130, H/2-10);
      g.fillStyle='#e9f2ff'; g.font='18px system-ui,Segoe UI,Arial'; g.fillText('Press R to restart', W/2-90, H/2+20);
    }
  }

  let last=0; function loop(ts){ const dt=Math.min(.033,(ts-last)/1000)||0; last=ts; time+=dt; if(state==='running'){ input(dt); updateEnemies(dt); updateBullets(dt); handleCollisions(); } draw(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

  // input
  addEventListener('keydown',e=>{ if(['ArrowLeft','ArrowRight','Space','KeyA','KeyD','KeyP','KeyR'].includes(e.code)) e.preventDefault(); if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=true; if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=true; if(e.code==='Space') keys.fire=true; if(e.code==='KeyP') state = state==='running'?'paused':'running'; if(e.code==='KeyR' && state==='gameover'){ score=0;lives=3;level=1; state='running'; resetLevel(); }});
  addEventListener('keyup',e=>{ if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=false; if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=false; if(e.code==='Space') keys.fire=false; });
})();
</script>
</body>
</html>
